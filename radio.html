<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radio Player</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            background: #121212;
        }
    </style>
</head>
<body>
    <audio id="audioStream" preload="auto" crossorigin="anonymous">
        <source id="audioSource" src="https://stream.revma.ihrhls.com/zc185" type="audio/mpeg">
    </audio>

    <script>
        const audio = document.getElementById('audioStream');
        const audioSource = document.getElementById('audioSource');
        
        let isPlaying = false;
        let currentStationIndex = 0;
        let audioContext = null;
        let sourceNode = null;

        const stations = [
            {
                name: 'KIIS-FM 102.7',
                streamUrl: 'https://stream.revma.ihrhls.com/zc185'
            },
            {
                name: 'Antena 1 94.7',
                streamUrl: 'https://antenaone.crossradio.com.br/stream/1;'
            }
        ];

        // Initialize Audio Context (browsers give this higher priority)
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                sourceNode = audioContext.createMediaElementSource(audio);
                sourceNode.connect(audioContext.destination);
                console.log('Audio Context initialized');
            }
            
            // Resume audio context if suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // Media Session API with proper metadata
        if ('mediaSession' in navigator) {
            navigator.mediaSession.setActionHandler('play', async () => {
                await reloadAndPlay();
            });

            navigator.mediaSession.setActionHandler('pause', () => {
                audio.pause();
                isPlaying = false;
                updateMediaSession();
            });

            navigator.mediaSession.setActionHandler('previoustrack', () => {
                switchStation(-1);
            });

            navigator.mediaSession.setActionHandler('nexttrack', () => {
                switchStation(1);
            });

            // Important: Handle seekbackward/seekforward to prevent default behavior
            navigator.mediaSession.setActionHandler('seekbackward', () => {
                // Do nothing - prevents browser from stopping playback
            });

            navigator.mediaSession.setActionHandler('seekforward', () => {
                // Do nothing - prevents browser from stopping playback
            });
        }

        function updateMediaSession() {
            if ('mediaSession' in navigator) {
                const currentStation = stations[currentStationIndex];
                document.title = currentStation.name;
                
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: currentStation.name,
                    artist: '',
                    album: '',
                    artwork: []
                });

                navigator.mediaSession.playbackState = isPlaying ? 'playing' : 'paused';
            }
        }

        async function reloadAndPlay() {
            initAudioContext();
            
            audio.load();
            try {
                await audio.play();
                isPlaying = true;
                updateMediaSession();
                console.log('Playing:', stations[currentStationIndex].name);
            } catch (err) {
                console.log('Play error:', err);
            }
        }

        function switchStation(direction) {
            currentStationIndex = (currentStationIndex + direction + stations.length) % stations.length;
            const station = stations[currentStationIndex];
            
            const wasPlaying = isPlaying;
            
            audio.pause();
            isPlaying = false;
            
            audioSource.src = station.streamUrl;
            updateMediaSession();
            
            if (wasPlaying) {
                setTimeout(() => reloadAndPlay(), 100);
            }
        }

        // Handle visibility change
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && isPlaying && audio.paused) {
                console.log('Page visible, resuming...');
                audio.play();
            }
            
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        });

        // Click to play
        document.body.addEventListener('click', async () => {
            if (!isPlaying) {
                await reloadAndPlay();
            }
        });

        // Update play state
        audio.addEventListener('play', () => {
            isPlaying = true;
            updateMediaSession();
        });

        audio.addEventListener('pause', () => {
            if (isPlaying) {
                // Only update if it was intentional pause
                isPlaying = false;
                updateMediaSession();
            }
        });

        // Initialize
        updateMediaSession();
        
        // Try auto-play
        setTimeout(() => {
            reloadAndPlay().catch(() => {
                console.log('Auto-play blocked. Click screen to start.');
            });
        }, 100);

        // Prevent scroll
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
